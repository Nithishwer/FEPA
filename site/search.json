{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Getting Started with FEPA","text":"<p>FEPA (Free Energy Perturbation Analysis) is a Python package for analyzing molecular dynamics (MD) trajectories from FEP simulations, particularly ABFEs. FEPA allows you to identify and visualize conformational changes in the trajectories and set up simulations to correct free energy estimates.</p> <p>This guide covers installation, basic usage, and key workflows.</p>","path":["Getting Started"],"tags":[]},{"location":"#prerequisites","level":2,"title":"Prerequisites","text":"<p>To make full use of FEPA's functionality, several additional programs are required:</p> <ul> <li>GROMACS ‚Äì for analyzing MD trajectories</li> <li>MODELLER ‚Äì from the Sali Lab, used for building missing residues or homology modeling.</li> <li>PLUMED ‚Äì for enhanced sampling or collective variable analysis.</li> <li>WHAM ‚Äì from Grossfield Lab, for estimating free energies from umbrella sampling or REUS simulations.</li> </ul> <p>Make sure these programs are installed and available in your system PATH so that FEPA can call them from Python.</p>","path":["Getting Started"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<p>FEPA must be installed from GitHub:</p> <pre><code>git clone https://github.com/Nithishwer/FEPA.git\ncd FEPA\npip install -e .\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"explanation/","level":1,"title":"üöß Explanation","text":"<p>Lorem Ipsum cause this page is under construction üõ†Ô∏èüë∑</p>","path":["Explanation"],"tags":[]},{"location":"reference/","level":1,"title":"üöß Reference","text":"<p>Lorem Ipsum cause this page is under construction üõ†Ô∏èüë∑</p> <p>::: fepa.core.analyzers ::: fepa.core.dim_reducers ::: fepa.core.ensemble_handler ::: fepa.core.featurizers ::: fepa.core.visualizers</p>","path":["Reference"],"tags":[]},{"location":"how-to-guides/guide-1/","level":1,"title":"Binding Pocket Resolvation Analysis","text":"<p>Visualizing binding pocket resolvation across ABFE simulations is straightforward with FEPA. We follow a workflow similar to Tutorial 1, but instead of <code>SelfDistanceFeaturizer</code>, we use <code>BPWaterFeaturizer</code> to quantify water occupancy.</p>","path":["How-to-guides","Binding Pocket Resolvation Analysis"],"tags":[]},{"location":"how-to-guides/guide-1/#1-load-config-and-prepare-paths","level":3,"title":"1. Load Config and Prepare Paths","text":"<pre><code>import logging, os\nfrom fepa.utils.file_utils import load_config\nfrom fepa.utils.path_utils import load_abfe_paths_for_compound\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n\nconfig = load_config(\"../../config/config.json\")\nanalysis_output_dir = \"wdir\"\ncmp = config[\"compounds\"][0]\n\nlogging.info(\"Analyzing compound %s ...\", cmp)\ncmp_output_dir = os.path.join(analysis_output_dir, cmp)\nos.makedirs(cmp_output_dir, exist_ok=True)\n\nlogging.info(\"Loading paths for compound %s...\", cmp)\npath_dict = load_abfe_paths_for_compound(\n    config,\n    cmp,\n    van_list=[1, 2, 3],\n    leg_window_list=[f\"coul.{i:02d}\" for i in range(0, 11)]\n                     + [f\"rest.{i:02d}\" for i in range(0, 12)]\n                     + [f\"vdw.{i:02d}\" for i in range(0, 21)],\n    bp_selection_string=\"name CA and resid 57 58 61 64 83 84 87 88 91 92 173 177 218 221 235 238 239 242 243 246\",\n    apo=False,\n)\n</code></pre>","path":["How-to-guides","Binding Pocket Resolvation Analysis"],"tags":[]},{"location":"how-to-guides/guide-1/#2-load-trajectories-and-featurize-waters","level":3,"title":"2. Load trajectories and featurize waters","text":"<pre><code>from fepa.core.ensemble_handler import EnsembleHandler\nfrom fepa.core.featurizers import BPWaterFeaturizer\n\nlogging.info(\"Loading trajectories for compound %s ...\", cmp)\nensemble_handler = EnsembleHandler(path_dict)\nensemble_handler.make_universes()\n\nlogging.info(\"Featurizing binding pocket waters ...\")\nbp_water_featurizer = BPWaterFeaturizer(ensemble_handler=ensemble_handler)\nbp_water_featurizer.featurize(radius=10)  # Count waters within 10 √Ö of pocket COM\n\nlogging.info(\"Saving features for compound %s ...\", cmp)\nbp_water_featurizer.save_features(cmp_output_dir, overwrite=True)\n</code></pre>","path":["How-to-guides","Binding Pocket Resolvation Analysis"],"tags":[]},{"location":"how-to-guides/guide-1/#3-plot-water-occupancy-over-time-or-windows","level":3,"title":"3. Plot Water Occupancy Over Time or Windows","text":"<pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfeatures_df = pd.read_csv(os.path.join(cmp_output_dir, \"WaterOccupancy_features.csv\"))\n\nfor van in [1, 2, 3]:\n    van_features_df = features_df[features_df[\"ensemble\"].str.contains(f\"van_{van}\")]\n    plt.figure(figsize=(12, 6))\n    sns.lineplot(data=van_features_df, x=\"Time (ps)\", y=\"occupancy\", hue=\"ensemble\")\n    plt.title(f\"Water Occupancy for {cmp}\")\n    plt.xlabel(\"Time (ps)\")\n    plt.ylabel(\"Number of Waters\")\n    plt.xlim(0, 20000)\n    plt.legend(title=\"Ensemble\", bbox_to_anchor=(1.05, 1), loc=\"upper left\", ncol=2)\n    plt.tight_layout()\n    plt.savefig(os.path.join(cmp_output_dir, f\"{cmp}_water_occupancy_van{van}.png\"))\n</code></pre> <pre><code># Extract vanilla replicate and window ID\nfeatures_df[\"van\"] = features_df[\"ensemble\"].str.extract(r\"van_(\\d)\")\nfeatures_df[\"id\"] = features_df[\"ensemble\"].str.replace(r\"_van_\\d+\", \"\", regex=True)\n\n# Compute average occupancy\navg_df = features_df.groupby([\"id\", \"van\"], as_index=False)[\"occupancy\"].mean()\navg_df.to_csv(os.path.join(cmp_output_dir, \"avg_water_occupancy.csv\"), index=False)\n\n# Plot average occupancy\nplt.figure(figsize=(12, 8))\nsns.lineplot(data=avg_df, x=\"id\", y=\"occupancy\", hue=\"van\", palette=\"tab10\")\nplt.title(f\"Average Water Occupancy Across Windows for {cmp}\", fontsize=16, fontweight=\"bold\")\nplt.xlabel(\"Window ID\", fontsize=14)\nplt.ylabel(\"Average Number of Waters\", fontsize=14)\nplt.legend(title=\"Vanilla Repeat\", title_fontsize=12, fontsize=10, loc=\"upper right\")\nplt.xticks(rotation=45, fontsize=10)\nplt.yticks(fontsize=10)\nplt.tight_layout()\nplt.savefig(os.path.join(cmp_output_dir, f\"{cmp}_water_occupancy_across_windows.png\"), dpi=300)\nplt.close()\n</code></pre> <p>Figure 1. Binding-pocket water solvation across ABFE windows for all compounds in the OX2R Deflorian et al. Set 1 dataset.</p>","path":["How-to-guides","Binding Pocket Resolvation Analysis"],"tags":[]},{"location":"how-to-guides/guide-2/","level":1,"title":"Side Chain Torsion Analysis","text":"<p>This workflow demonstrates how to use FEPA to analyze side-chain torsion angle distributions across ABFE ensembles. The procedure closely follows the feature-extraction workflow from Tutorial 1, but instead of <code>SelfDistanceFeaturizer</code>, we use <code>SideChainTorsionsFeaturizer</code> to compute œá-angle torsions for binding-pocket residues.</p>","path":["How-to-guides","Side Chain Torsion Analysis"],"tags":[]},{"location":"how-to-guides/guide-2/#1-loading-abfe-trajectories-and-setting-up-the-featurizer","level":3,"title":"1. Loading ABFE Trajectories and Setting Up the Featurizer","text":"<p>We begin by loading the trajectories for the compound of interest, defining the relevant ABFE Œª-windows, and preparing the EnsembleHandler:</p> <pre><code>from fepa.utils.file_utils import load_config\nfrom fepa.core.ensemble_handler import EnsembleHandler\nfrom fepa.utils.path_utils import load_abfe_paths_for_compound\nfrom fepa.core.featurizers import SideChainTorsionsFeaturizer\n\n# Load configuration\nconfig_path = os.path.join(\"../../config/config.json\")\nconfig = load_config(config_path)\nanalysis_output_dir = os.path.join(\"wdir\")\ncmp = config[\"compounds\"][1]\n\n# Create output directory\ncmp_output_dir = os.path.join(analysis_output_dir, cmp)\nos.makedirs(cmp_output_dir, exist_ok=True)\n\n# Prepare paths\nlogging.info(\"Loading paths for compound %s...\", cmp)\npath_dict = load_abfe_paths_for_compound(\n    config,\n    cmp,\n    van_list=[1, 2, 3],\n    leg_window_list= [f\"vdw.{i:02d}\" for i in range(20, 21)] +\n     [f\"coul.{i:02d}\" for i in range(0, 11)] + \n     [f\"rest.{i:02d}\" for i in range(0, 12)],\n    bp_selection_string=\"name CA and resid \" + config[\"pocket_residues_string\"],\n    apo=True,\n)\n\n# Load trajectories\nlogging.info(\"Loading trajectories for compound %s ...\", cmp)\nensemble_handler = EnsembleHandler(path_dict)\nensemble_handler.make_universes()\n\n# Featurize\nlogging.info(\"Featurizing binding pocket torsions ...\")\nsct_featurizer = SideChainTorsionsFeaturizer(ensemble_handler=ensemble_handler)\nsct_featurizer.featurize()\n\n# Save features\nlogging.info(\"Saving features for compound %s ...\", cmp)\nsct_featurizer.save_features(cmp_output_dir, overwrite=True)\n</code></pre> <p>This extracts œá-angle torsions for all binding-pocket residues across the apo and ABFE ensembles defined above.</p>","path":["How-to-guides","Side Chain Torsion Analysis"],"tags":[]},{"location":"how-to-guides/guide-2/#2-annotating-and-visualizing-side-chain-torsion-distributions","level":3,"title":"2. Annotating and Visualizing Side-Chain Torsion Distributions","text":"<p>We can now load the computed feature table and annotate each frame with its simulation type (apo vs. ABFE). This metadata is used to color the distributions in the plot.</p> <pre><code>import pandas as pd\n\n# Loading the featured column\nfeatures_df = pd.read_csv(\n    os.path.join(cmp_output_dir, f\"SideChainTorsions_features.csv\")\n)\n\n# Function to get the simulation type\ndef get_sim_type(ensemble):\n    if \"apo\" in ensemble:\n        return \"apo\"\n    if \"coul\" in ensemble or \"vdw\" in ensemble or \"rest\" in ensemble:\n        match = re.search(r\"van_(\\d+)\", ensemble)\n        if match:\n            return f\"abfe\"\n        else:\n            raise ValueError(f\"van not found in ensemble: {ensemble}\")\n    else:\n        return \"holo\"\n\n# Annotate sim_type for features_df\nfeatures_df[\"sim_type\"] = features_df[\"ensemble\"].apply(\n    get_sim_type\n)\n</code></pre> <p>We then generate torsion-angle histograms using FEPA‚Äôs built-in visualization utility:</p> <pre><code># Plot sidechain distribution\nplot_sidechain_distribution(\n    df=features_df,\n    ensembles=[\"abfe\", \"apo\"],\n    colorby=\"sim_type\",\n    output_file=os.path.join(\n        cmp_output_dir, f\"{cmp}_sidechain_histograms_simtype_abfe_apo.png\"\n    ),\n    ncols=4,\n)\n</code></pre> <p></p> <p>Figure 1. Side-chain angle distributions for the apo and ABFE ensembles.</p>","path":["How-to-guides","Side Chain Torsion Analysis"],"tags":[]},{"location":"how-to-guides/guide-2/#other-useful-utilities-comparing-torsions-of-starting-poses","level":3,"title":"Other useful utilities: Comparing torsions of starting poses","text":"<p>Often times, differences in sidechain torsions between starting frames of ABFEs result in huge differences in the binding affinity as independant runs are sampling different conformations. To account for this, we must be mindful of the sidechain torsion differences between different repeats. This can be done by using the <code>read_protein_sidechain_torsions</code> function from PENSA.</p> <pre><code>from pensa.features import read_protein_sidechain_torsions\n\ndf_list = []\n\n# Get gro paths for different vanilla runs\nfor van in van_runs:\n    gro_path = f\"OX2_{cmp}/abfe_van{van}_hrex_r1/complex/complex.gro\"\n    name, data = read_protein_sidechain_torsions(\n        gro_path,\n        gro_path,\n        selection=bp_selection_string,\n    )\n    df = pd.DataFrame(data, columns=name)\n    df[\"structure\"] = f\"OX2_{cmp}_van{van}\"\n    df_list.append(df)\n\n# Combine all dfs in df_list into a single df\ntorsions_df = pd.concat(df_list, ignore_index=True)\n</code></pre> <p>This could then be visualized with the <code>plot_torsions_to_png</code> function which plots the torsions in decending order of spread between the different structures.</p> <pre><code>from fepa.utils.plot_utils import plot_torsions_to_png\n\n# Plot the dataframe\nplot_torsions_to_png(\n    torsions_df, savedir=\"torsion_plots\"\n)\n</code></pre> <p> Figure 2. Torsions shown in decreasing order of their variation across different starting frames.</p>","path":["How-to-guides","Side Chain Torsion Analysis"],"tags":[]},{"location":"how-to-guides/guide-3/","level":1,"title":"Ligand conformations","text":"<p>This workflow shows how FEPA could be used to evaluate binding-pose similarity across ensembles. To do this, we will load ABFE trajectories, cluster binding poses using MDAnalysis Encore, and export both cluster assignments and representative centroid structures for visualization.</p>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"how-to-guides/guide-3/#1-loading-abfe-trajectories","level":3,"title":"1. Loading ABFE Trajectories","text":"<p>We begin by loading the trajectories for a given compound and initializing the <code>EnsembleHandler</code> object:</p> <pre><code>import logging, os\nfrom fepa.utils.file_utils import load_config\nfrom fepa.utils.path_utils import load_abfe_paths_for_compound\nfrom fepa.core.ensemble_handler import EnsembleHandler\n\n# Load configuration\nconfig_path = os.path.join(\"../../config/config.json\")\nconfig = load_config(config_path)\nanalysis_output_dir = \"./wdir\"\nos.makedirs(analysis_output_dir, exist_ok=True)\n\nvan_list = [1, 2, 3]\nleg_window_list = (\n    [f\"coul.{i:02}\" for i in range(0, 11, 2)]\n    + [f\"vdw.{i:02}\" for i in range(0, 12, 2)]\n    + [f\"rest.{i:02}\" for i in range(0, 11, 2)]\n)\n\npath_dict = load_abfe_paths_for_compound(\n    config,\n    cmp=cmp,\n    bp_selection_string=\"name CA and resid \" + config[\"pocket_residues_string\"],\n    van_list=van_list,\n    leg_window_list=leg_window_list,\n    apo=False,\n)\n\n# Load trajectories\nensemble_handler = EnsembleHandler(path_dict)\nensemble_handler.make_universes()\n\ncheck_bp_residue_consistency(ensemble_handler.get_universe_dict())\n</code></pre> <p>Here we collect all holo ensembles, ensure pocket residues are consistent across trajectories, and prepare the universes for analysis.</p>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"how-to-guides/guide-3/#2-clustering-ligand-binding-poses","level":3,"title":"2. Clustering Ligand Binding Poses","text":"<p>We then perform binding-pose clustering using DBSCAN from MDAnalysis Encore. Each cluster represents a distinct ligand binding mode shared across the ensemble set.</p> <p><pre><code>sel = \"resname unk\"\nuniverse_dict = ensemble_handler.get_universe_dict()\n# Define clustering method\ndbscan_method = encore.DBSCAN(\n    eps=0.5, min_samples=5, algorithm=\"auto\", leaf_size=30\n)\n# Define the ensemble list\nensemble_list = list(universe_dict.values())\n# Cluster the binding poses\ncluster_collection = encore.cluster(\n    ensembles=ensemble_list,\n    select=sel,\n    superimposition_subset=\"name CA\",\n    method=dbscan_method,\n)\n</code></pre> This aligns the complexes on CŒ± atoms and clusters ligand heavy-atom coordinates to identify recurring conformations.</p>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"how-to-guides/guide-3/#3-saving-framewise-cluster-assignments","level":3,"title":"3. Saving Framewise Cluster Assignments","text":"<p>The cluster identity for each frame is stored in a DataFrame and written to disk:</p> <pre><code>cluster_df = pd.DataFrame({\n    \"timestep\": timstep_series,\n    \"ensemble\": ensemble_series,\n    \"cluster\": cluster_series,\n})\ncluster_df.to_csv(\n    os.path.join(cmp_output_dir, f\"{cmp}_conformation_cluster_df.csv\"),\n    index=False,\n)\n</code></pre>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"how-to-guides/guide-3/#4-exporting-cluster-centroid-structures","level":3,"title":"4. Exporting Cluster Centroid Structures","text":"<p>For visualization in PyMOL or ChimeraX, we extract each cluster‚Äôs centroid frame as a PDB file:</p> <pre><code>ensemble_handler.dump_frames(\n    ensemble=centroid_ensemble,\n    timestep=centroid_timestep,\n    save_path=os.path.join(\n        cmp_output_dir,\n        f\"{cmp}_conformation_cluster_{cluster_id}.pdb\",\n    ),\n)\n</code></pre> <p>These structures serve as representative snapshots of each binding mode.</p>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"how-to-guides/guide-3/#5-visualizing-cluster-populations","level":3,"title":"5. Visualizing Cluster Populations","text":"<p>We can summarize cluster occupancy across ensembles using a simple stacked bar plot:</p> <pre><code># Plot a stacked barplot of clusters in each ensemble\ncluster_counts = (\n    cluster_df.groupby([\"ensemble\", \"cluster\"]).size().unstack(fill_value=0)\n)\ncluster_counts.plot(\n    kind=\"bar\",\n    stacked=True,\n    figsize=(10, 6),\n    colormap=\"Set2\",\n)\nplt.title(f\"Cluster distribution in each ensemble for {cmp}\")\nplt.xlabel(\"Ensemble\")\nplt.ylabel(\"Count\")\nplt.xticks(rotation=90)\nplt.legend(title=\"Cluster\", bbox_to_anchor=(1.05, 1), loc=\"upper left\")\nplt.tight_layout()\nplt.savefig(\n    os.path.join(\n    analysis_output_dir,\n    f\"{cmp}_conformation_cluster_distribution.png\",\n    )\n)\nplt.close()\n</code></pre> <p>This visualization highlights whether certain Œª-windows prefer specific ligand poses, helping diagnose convergence and structural consistency across ABFE simulations.</p> <p> Figure 1. Stacked bar plot of conformations for ligand 46853 (OX2R, Deflorian et al set 1) across ABFE windows for three ABFE runs. The ligand adopts one pose in run 1 and a different pose in runs 2 and 3.</p> <p> Figure 2. Visualization of the PDBs shows that while the binding poses in clusters 0 and 1 are crystal-like and similar to each other, they differ in the orientation of the triazole ring. Cluster 2, however, is very different. Fortunately, cluster 2 is rare in the simulations, so the calculations predominantly reflect the crystal-like pose.</p>","path":["How-to-guides","Ligand conformations"],"tags":[]},{"location":"tutorials/tutorial-1/","level":1,"title":"Featurizing ABFEs","text":"<p>This tutorial is designed to the user to introduce fepa by analyzing MD data from a set of simulations of the ligand 42922 (from the Deflorian et al set 1 datset) bound to the Orexin 2 Receptor. Specifically, we will compare the holo, apo and ABFE trajectories. Through this comparison, we will demonstrate that the protein‚Äôs binding pocket adopts distinct conformations between the final lambda windows (where the ligand is fully annihilated) of the ABFE simulation and the long apo simulation of the receptor.</p> <p>This tutorial is followed by Tutorial 2 where we will use FEPA to set up REUS simulations to estimate the free energy of this conformational change from the holo like  to apo like states. This tutorial uses MDAnalysis, MDtraj and the PENSA package for analysis, GROMACS for simulation and Plumed for enhanced sampling. It is assumed that the user is familiar with setting up and analyzing MD simulations run with GROMACS and Plumed. </p>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#loading-the-config-file","level":2,"title":"Loading the config file","text":"<p>ABFE simulations produce multiple MD trajectories over different lamba windows. In our case, we have 44 lambda windows (11 Coulomb, 12 Restrains and 22 Van-der-Walls) plus the holo and the apo simulations that we have to analyse. To make things easier when parsing paths to the topology and coordinate files of these trajectories, we use a config file. The config file is json-formatted and contains all the information necessary to read the simulation trajectories. Here is a sample config file that I use for this tutorial:</p> <pre><code>{\n    \"base_path\": \"deflorian_set_1_j13_v1\",\n    \"abfe_window_path_template\": \"deflorian_set_1_j13_v1/OX2_{CMP_NAME}/abfe_van{REP_NO}_hrex_r{ABFE_REP_NO}/complex/{LEG_WINDOW}/{STAGE}\",\n    \"vanilla_path_template\": \"deflorian_set_1_j13_v1/OX2_{CMP_NAME}/vanilla_rep_{REP_NO}\",\n    \"apo_path_template\": \"deflorian_set_1_j13_v1/apo_OX2_r{REP_NO}\",\n    \"compounds\": [\n        \"42922\",\n    ],\n    \"pocket_residues_string\": \"12  54  57  58  59  60  61  62  63  64  65  70  71  78  81  82  83  85  86  89 138 142 160 161 162 163 175 178 179 182 183 232 235 236 239 240 242 243 261 265 268 269\"\n}\n</code></pre> <p>The pocket_residues_string variable is a string that stores the residue ids of all the proteins residue that have any atom within 6 A of the ligand. The JSON file is then loaded into a dictionary with the function <code>load_config</code> from <code>fepa.utils.file_utils</code></p>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#loading-md-trajectories","level":2,"title":"Loading MD trajectories","text":"<p>Now that we have the template paths to all the simulations: Apo EQ, Holo EQ and ABFE, we can use the function <code>load_abfe_paths_for_compound</code> from fepa.utils.path_utils to generate a <code>path_dict</code> dictionary that contains all the MD file paths for a single compound as follows:</p> <pre><code>cmp = config['compounds'][0]\npath_dict = load_abfe_paths_for_compound(\n            config,\n            cmp,\n            van_list=[3], # Loading only vanilla simulation 3\n            leg_window_list=[f\"coul.{i:02d}\" for i in range(0, 11,2)] + [f'vdw.{i:02d}' for i in range(0, 21,2)] + [f'rest.{i:02d}' for i in range(0, 12,2)], # Loading only every other lambda window\n            bp_selection_string=\"name CA and resid \" + config[\"pocket_residues_string\"],\n            apo=True,\n        )\n</code></pre> <p>The <code>load_abfe_paths_for_compound</code> function has various arguments that allow the user control over what simulation paths are loaded. For more information, please refer to the API. </p> <p>Now that we have the path_dict, it is time for us to load the trajectories themselves. We will be using the EnsembleHandler class from fepa.core.ensemble_handler to do this. EnsembleHandler is a neat way of storing and manipulating the trajectories from multiple ensembles with some built in functions for sanity checks. Internally EnsembleHandler stores the trajectories as dictionary of MDA universes.  </p> <p>TODO: Need to remove ensemblehandler and just use universe dict</p> <pre><code># Load trajectories\nensemble_handler = EnsembleHandler(path_dict)\n# Make universes\nensemble_handler.make_universes()\nlogging.info(\"Making universes for compound %s...\", cmp)\n# Check for BP residue consistency across all the trajectories\nlogging.info(\"Checking residue consistency for compound %s...\", cmp)\n</code></pre>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#featurizing-md-trajectories","level":2,"title":"Featurizing MD trajectories","text":"<p>We will now be featurizing these trajectories by their pairwise C-alpha distances in the binding pocket using the function <code>SelfDistanceFeaturizer</code> from <code>fepa.core.featurizers</code>. <code>SelfDistanceFeaturizer</code> computes and stored all possible pairs of distances between the C-alpha atoms of the binding pocket residues. The class also has <code>save_features</code> and <code>load_features</code> functions that help save the features as a csv file to make sure the time consuming featurization step need not be repeated every run.</p> <p>TODO: Make sure the binding pocket selection is consistent</p> <pre><code># Make a folder for the analysis output\ncmp_run_dir = f'analysis/{cmp}/'\nif !(os.path.exists(cmp_run_dir)):\n    os.mkdir(cmp_run_dir)\n\n# Featurize and save features\nfeaturizer = SelfDistanceFeaturizer(ensemble_handler)\nfeaturizer.featurize()\nfeaturizer.save_features(input_dir=cmp_existing_run_dir)\n</code></pre>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#visualizing-ensembles","level":2,"title":"Visualizing ensembles","text":"<p>Saving the features in a csv format gives us the flexibility to analyse it as required. For the purpose of this tutorial, we will be looking at how our features capture the difference between the apo, the holo and the abfe ensembles. To do this we reduce the dimensions of the features data using the <code>PCADimReducer</code> class from <code>fepa.core.dim_reducers</code>. FEPA also supports other dimensionality reduction techniqeus like UMAP and tSNE. In fact UMAP is better able to resolve the differences in binding pocket configurations between different ensembles. We will be doing PCA here as it also doubles up as a nice CV to bias when performing umbrella sampling later.</p> <pre><code># Dimensionality Reduction\nlogging.info(\"Performing dimensionality reduction for compound %s...\", cmp)\ndimreducer = PCADimReducer(featurizer.get_feature_df(), n_components=8)\ndimreducer.reduce_dimensions()\ndimreducer.calculate_projections()\ndimreducer.save_projection_df(\n    save_path=os.path.join(cmp_output_dir, \"pca_projection_df.csv\")\n)\n</code></pre> <p>First we plot the eigen values of all the PCs to understand what percentage of variance is captured by the first few PCs:</p> <pre><code>logging.info(\"Plotting PCA eigenvalues for compound %s...\", cmp)\nplot_eigenvalues(\n    pca_object=dimreducer.get_pca(),\n    n_components=8,\n    save_path=os.path.join(cmp_output_dir, \"eigenvalues.png\"),\n)\n</code></pre> <p></p> <p>Figure 1: PCA eigenvalues for the binding-pocket CŒ± self-distance features.</p> <p>Here, most of the variance is captured by PC1. However, this may not always be the case. Therefore, for this tutorial, we will use PC1 and PC2 together, as they collectively capture the majority of the variance. To improve visualization, we define a new column in <code>projection_df</code> called <code>simtype</code>, which groups the ensembles into broader categories: <code>abfe_coul</code>, <code>abfe_vdw</code>, <code>abfe_rest</code>, <code>holo_equil</code>, <code>apo</code>, and <code>nvt</code>.</p> <pre><code># Further labelling the ensembles\nprojection_df = dimreducer.get_pca_projection_df()\n# Add another column called simtype based on ensemble\ndef get_simtype(ensemble_name: str) -&gt; str:\n    if \"van\" in ensemble_name:\n        if 'nvt' in ensemble_name:\n            return \"nvt\"\n        if \"coul\" in ensemble_name:\n            return \"abfe_coul\"\n        elif \"vdw\" in ensemble_name:\n            return \"abfe_vdw\"\n        elif \"rest\" in ensemble_name:\n            return \"abfe_rest\"\n        else:\n            return \"holo_equil\"\n    elif \"apo\" in ensemble_name:\n        return \"apo\"\n    else:\n        return \"other\"\nprojection_df[\"simtype\"] = projection_df[\"ensemble\"].apply(get_simtype)\n</code></pre> <p>We can visualize the dimensionality-reduced data using the <code>DimRedVisualizer</code> class. In the example below, we plot the first two principal components, colored by simulation and time. We also highlight NVT, as it represents the initial crystal structure after energy minimization.</p> <pre><code>logging.info(\"Visualizing compound %s...\", cmp)\ndimred_visualizer = DimRedVisualizer(projection_df=projection_df, data_name=\"PCA\")\ndimred_visualizer.plot_dimred_sims(\n    save_path=os.path.join(cmp_run_dir, \"pca_components_ensemble_noapo.png\"),\n    highlights=[f\"{cmp}_nvt\"],\n)\ndimred_visualizer.plot_dimred_time(\n    save_path=os.path.join(cmp_run_dir, \"pca_components_time_noapo.png\")\n)\ndimred_visualizer.plot_dimred_sims(\n    column=\"simtype\",\n    save_path=os.path.join(cmp_run_dir, \"pca_components_simtype.png\"),\n)\n</code></pre> <p> Figure 2: Simulation frames in PC-space (PC1 vs PC2), colored by simtype</p>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#clustering-ensembles","level":2,"title":"Clustering ensembles","text":"<p>In Figure 2, frames from the ABFE simulations closely resemble those from the holo equilibrium simulation, forming two distinct clusters: apo-like and holo-like. We will be clustering them using <code>cluster_pca</code>. After clustering, we can estimtate the data point that is closest to the center with the function <code>make_ensemble_center_df</code> which returns a <code>DataFrame</code> containing the details of the frame closest to the centroid in PC space. </p> <pre><code># Cluster the projection df\npca_projection_df_clustered = cluster_pca(\n    projection_df, n_clusters=3, n_components=3\n)\n# Ensemble center df\nensemble_center_df = make_ensemble_center_df(\n    pca_projection_df_clustered, key=\"cluster\"\n)\n</code></pre> <p>We then visualize the clustered data with ensemble centers as follows:</p> <pre><code># Visualization of clustered data\ndimred_visualizer_clustered = DimRedVisualizer(\n    projection_df=pca_projection_df_clustered, data_name=\"PCA\"\n)\ndimred_visualizer_clustered.plot_dimred_cluster(\n    save_path=os.path.join(\n        cmp_run_dir, \"subset_pca_components_clusters_w_center.png\"\n    ),\n    centroid_df=ensemble_center_df,\n    cluster_column=\"cluster\",\n)\n</code></pre> <p></p> <p>Figure 3: Clustered PCA data with ensemble centers marked by an X.</p>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-1/#visualizing-differences-across-clustered-ensembles","level":2,"title":"Visualizing differences across clustered ensembles","text":"<p>With two distinct clusters identified, we can compare them across different features by computing the Jensen‚ÄìShannon (JS) entropy for each feature. The code below plots feature-wise histograms for cluster 0 and cluster 1, annotated with their JS entropy values:</p> <pre><code># Copy the cluster labels from pca_projection_df_clustered to feature_df\nfeature_df_w_clusters = featurizer.get_feature_df().copy()\nfeature_df_w_clusters[\"cluster\"] = pca_projection_df_clustered[\"cluster\"].values\n\n\n# Compute feature-level histograms and JS entropy between clusters 0 and 1\nhistograms = compute_histograms(\n    feature_df_w_clusters,\n    \"cluster\",\n    0,\n    1,\n    num_bins=50,\n    feature_column_keyword=\"DIST\",\n)\n\nrel_ent_dict = compute_relative_entropy(\n    feature_df_w_clusters,\n    ensemble1=0,\n    ensemble2=1,\n    num_bins=50,\n    key=\"cluster\",\n    feature_column_keyword=\"DIST\",\n)\n\nplot_jsd_histograms(\n    histograms,\n    rel_ent_dict,\n    top_n=16,\n    save_path=os.path.join(cmp_run_dir, \"jsd_cluster0_vs_cluster1.png\"),\n)\n</code></pre> <p> Figure 4: Histograms of the top 16 features showing the highest Jensen‚ÄìShannon divergence between clusters 0 and 1.</p> <p>We then save the ensemble center frames as GRO files to compare structures in molecular visualization tools such as PyMOL:</p> <pre><code># Save ensemble center frames as GRO files\nfor _, row in ensemble_center_df.iterrows():\n    center_ensemble = row[\"ensemble\"]\n    center_timestep = row[\"timestep\"]\n    print(f\"Ensemble: {center_ensemble}, Timestep: {center_timestep}\")\n\n    # Load trajectories\n    ensemble_handler.make_universes()\n\n    # Export the frame corresponding to the ensemble center\n    ensemble_handler.dump_frames(\n        ensemble=center_ensemble,\n        timestep=center_timestep,\n        save_path=f\"subset_cluster_{int(row['cluster'])}_center.gro\",\n    )\n</code></pre> <p>The analysis in this tutorial can also be performed using FEPA‚Äôs workflow classes, which provide minimal-boilerplate interfaces for running standard ABFE analysis. These workflows reproduce the same binding pocket analysis shown here, but with far less user-written code. You can find ready-to-use workflow examples in the <code>fepa/examples</code> directory.</p>","path":["Tutorials","Featurizing ABFEs"],"tags":[]},{"location":"tutorials/tutorial-2/","level":1,"title":"Setting up REUS","text":"<p>In Tutorial 2, we build on the concepts learned in Tutorial 1, where the apo and holo states were shown to form distinct conformational clusters. Using the data provided in the [template], we will set up Replica Exchange Umbrella Sampling (REUS) simulations to estimate the free energy of the conformational transition from holo to apo, using the principal component (PC) 1 as the collective variable (CV). We will achieve this by morphing the protein from one state to another, equilibrating the system, and then running REUS to sample the transition.</p>","path":["Tutorials","Setting up REUS"],"tags":[]},{"location":"tutorials/tutorial-2/#preparing-the-plumeddat-file","level":2,"title":"Preparing the plumed.dat file","text":"<p>The first step in performing umbrella sampling with GROMACS and PLUMED is to create a plumed.dat file that defines the collective variable (CV), and the positions of the umbrella sampling restraints. To do this, we load the feature CSV files, initialize a DimReducer object, and extract the corresponding PCA object to define the CV based on pairwise CŒ± distances.</p> <pre><code># Load Features df and reduce dimensions\nfeature_df = pd.read_csv(os.path.join(\"md_data\", \"top_features_apo_vdw.20.csv\"))\ndimreducer = PCADimReducer(feature_df, n_components=8)\ndimreducer.reduce_dimensions()\ndimreducer.calculate_projections()\npca_projection_df = dimreducer.get_pca_projection_df()\n# Use PCA from dimreducer to write plumed file\ntop_features = feature_df.filter(regex=\"DIST\", axis=1).columns\nwrite_plumed_file(\n    sdf_names=top_features,\n    top_features_pca=dimreducer.get_pca(),\n    save_path=\"plumed.dat\",\n    molinfo_structure=\"../reference.pdb\",  # fix molinfo here\n)\n</code></pre> <p>The PLUMED input file should look like this:</p> <p><pre><code>MOLINFO STRUCTURE=../reference.pdb\nd1: DISTANCE ATOMS=@CA-236,@CA-243\nd2: DISTANCE ATOMS=@CA-175,@CA-243\nd3: DISTANCE ATOMS=@CA-138,@CA-243\n.\n.\n.\nd200: DISTANCE ATOMS=@CA-61,@CA-70\n# Create the dot product\ndot: COMBINE ARG=d1,d2,d3...d200 COEFFICIENTS=0.095,0.152,0.133...0.057,0.054,0.032 PERIODIC=NO\nCV: MATHEVAL ARG=dot FUNC=10*x PERIODIC=NO\nPRINT ARG=CV FILE=COLVAR STRIDE=1\n# Put position of restraints here for each window\nrestraint: RESTRAINT ARG=CV AT=@replicas:$RESTRAINT_ARRAY KAPPA=$KAPPA\nPRINT ARG=restraint.* FILE=restr\n</code></pre> Note that $RESTRAINT_ARRAY is a placeholder for the harmonic restraint positions in CV space. When defining these positions, ensure they align with the direction of the structural morph. By convention, we transition from vdw.20 to apo structures. To assign restraints correctly, identify the ensemble with the lowest PC value and order the restraints from min to max (or vice versa) accordingly.</p> <pre><code># Pair of ensembles to compare\npair = (\"vdw.20\", \"apo\")\n# Get mean PC1 for the two ensembles\nmean_pc1_ensemble1 = pca_projection_df[pca_projection_df[\"state\"] == pair[0]][\n    \"PC1\"\n].mean()\nmean_pc1_ensemble2 = pca_projection_df[pca_projection_df[\"state\"] == pair[1]][\n    \"PC1\"\n].mean()\nlogging.info(\n    f\"Mean PC1 for {pair[0]}: {mean_pc1_ensemble1}, Mean PC1 for {pair[1]}: {mean_pc1_ensemble2}\"\n)\n# Get the restraint array based on the two ensembles\nPC1_min = pca_projection_df[\"PC1\"].min()\nPC1_max = pca_projection_df[\"PC1\"].max()\n# If min PC1 is from ensemble 1, then the restraint array should be from PC1_min to PC1_max\nif mean_pc1_ensemble1 &lt; mean_pc1_ensemble2:\n    restraint_array = np.linspace(PC1_min, PC1_max, 24)\nelif mean_pc1_ensemble1 &gt; mean_pc1_ensemble2:\n    restraint_array = np.linspace(PC1_max, PC1_min, 24)\n</code></pre> <p>Once the restraint array is prepared, we write it to the PLUMED file using the write_plumed_restraints function:</p> <pre><code># Write the restraint array to the plumed file\nwrite_plumed_restraints(\n    plumed_file=\"plumed.dat\",\n    restraint_centers=restraint_array,\n    kappa=5,\n)\n</code></pre> <p>The restrain line on plumed.dat file must now be an array of distance restraints that looks like this:</p> <pre><code>restraint: RESTRAINT ARG=CV AT=@replicas:116.856,119.047,121.239...167.262 KAPPA=5\n</code></pre>","path":["Tutorials","Setting up REUS"],"tags":[]},{"location":"tutorials/tutorial-2/#morphing-with-memento","level":2,"title":"Morphing with memento","text":"<p>For this tutorial, the GRO files representing the vdw.20 and apo states are provided in the data folder, prepared in the same way as in Tutorial 1. The plumed.dat file has also been prepared. The next step for REUS is to generate intermediate protein conformations using Memento (JCTC, 2023) . FEPA provides a class for easy access to Memento.</p> <p>Using FEPA‚Äôs <code>memento_workflow</code> class, we can perform the protein morphing. A Memento directory is needed to store morphs for each entry in initial_target_gro_dict, and an apo_template path must be provided, containing the topology and MDP files required for equilibrium simulations.</p> <pre><code># Declaring variables:\nmemento_dir = \"/biggin/b211/reub0138/Projects/orexin/deflorian_set_1_j13_v1_memento\"\n# Defining pairs\npair = (\"all_vdw20\", \"apo_3\")\nall_vdw20_gro_file = \"/biggin/b211/reub0138/Projects/orexin/deflorian_set_1_j13_v1/analysis/a12_dimreduce_vdw.20/subset_cluster_1_center.gro\"\napo_3_gro_file = \"/biggin/b211/reub0138/Projects/orexin/deflorian_set_1_j13_v1/analysis/a12_dimreduce_vdw.20/subset_cluster_2_center.gro\"\ntemplate_path = \"/biggin/b211/reub0138/Projects/orexin/deflorian_set_1_j13_v1_memento/apo_template\"  # Make sure no water and no ions in the template topology file\n# Setup Memento folders\nmemento_flow = memento_workflow(\n    memento_dir=memento_dir,\n    initial_gro=all_vdw20_gro_file,\n    target_gro=apo_3_gro_file,\n    initial_name=pair[0],\n    target_name=pair[1],\n    template_path=template_path,\n    run_name=\"memento_run_v1\",\n    n_residues=296,\n)\n</code></pre> <p>We can use the workflow functions to perform each step. First, <code>prepare_memento</code> sets up the files required by Memento. Then, <code>run_memento</code> executes the morphing. <code>run_memento</code> requires the protonation states of all histidines in the format expected by GROMACS pdb2gmx (0 for HID, 1 for HIE, 2 for HIP, 3 for HIS1). Additionally, the indices of CYX residues must be provided, as Memento cannot process them automatically.</p> <pre><code># Preparing memento input\nmemento_flow.prepare_memento()\n# Running memento\nmemento_flow.run_memento(\n    template_path=template_path,\n    last_run=\"memento_run_v1\",\n    protonation_states=[1, 1, 1, 2, 1, 2],\n    cyx_residue_indices = []\n)\n</code></pre>","path":["Tutorials","Setting up REUS"],"tags":[]},{"location":"tutorials/tutorial-2/#running-equilibration","level":2,"title":"Running Equilibration","text":"<p>This step may take some time. Once complete, we can set up equilibration simulations with Memento by providing a job script path, which can be modified to suit the specific HPC system.</p> <pre><code># Running analysis\nmemento_flow.prepare_equil_simulations(\n    job_script_template=\"/biggin/b211/reub0138/Projects/orexin/lenselink_a2a_memento_v1/job_vanilla_ranv_equil_arr_template.sh\"\n)\n</code></pre> <p>After running prepare_equil_simulations, individual boxes for each morph are created. We then simulate each box to relax the side chains by submitting the job to our HPC. Once complete, we can proceed to the REUS simulations.</p>","path":["Tutorials","Setting up REUS"],"tags":[]},{"location":"tutorials/tutorial-2/#preparing-reus","level":2,"title":"Preparing REUS","text":"<p>Once the equilibration simulations are complete, use FEPA‚Äôs <code>reus_umbrella_sampling_workflow</code> class to set up umbrella sampling in the same working directory. The number of windows can be adjusted via <code>n_windows</code> (24 is typically sufficient). If the residue IDs in the plumed.dat file does not match those in the MD GRO files, FEPA requires the correct offset to be set via the <code>plumed_resid_offset</code> parameter.</p> <pre><code>import logging\nfrom pathlib import Path\nfrom fepa.flows.reus_flows import (\n    reus_umbrella_sampling_workflow,\n)\n\nsim_path = \"wdir/all_vdw20_apo_3/memento_run_v1/wdir/boxes/sim0\"\nwdir_path = Path(sim_path).parents[1]\nplumed_path = \"plumed.dat\"\nsimname = \"all_vdw20_apo_3\"\ninitial_gro = \"md_data/cluster_1_center.gro\"\nfinal_gro = \"md_data/cluster_2_center.gro\"\nsubmission_script_template_arr = \"md_data/job_reus_template.sh\"\nprint(f\"wdir_path: {wdir_path}, plumed_path: {plumed_path}\")\numbrella_sampler = reus_umbrella_sampling_workflow(\n    wdir_path=wdir_path,\n    plumed_path=plumed_path,\n    submission_script_template_arr=submission_script_template_arr,\n    start=simname.split(\"_\")[0] + \"_\" + simname.split(\"_\")[1],\n    end=simname.split(\"_\")[2] + \"_\" + simname.split(\"_\")[3],\n    reus_folder_name=\"reus_v1\",\n    n_windows=24,\n    plumed_resid_offset=0,\n    initial_gro=initial_gro,\n    target_gro=final_gro,\n)\numbrella_sampler.setup_simulations(exist_ok=True)\n</code></pre>","path":["Tutorials","Setting up REUS"],"tags":[]},{"location":"tutorials/tutorial-2/#analyzing-reus","level":2,"title":"Analyzing REUS","text":"<p>Once your REUS system is set up, you can analyze the results using the workflow:</p> <pre><code>umbrella_sampler.prepare_wham()\numbrella_sampler.run_wham()\numbrella_sampler.analyse_us_hist(range=(90, 180), colvar_prefix=\"COLVAR\")\numbrella_sampler.get_initial_final_CVs()\numbrella_sampler.plot_free_energies(\n    units=\"kcal\",\n)\n</code></pre> <p>This prepares and runs WHAM on the histograms and generates the free energy curves.</p> <p></p> <p>Figure 1: Free energy curves from the tutorial simulations. The CV values of apo and holo structures are marked with gray dotted lines. Different lines represent curves computed using varying proportions of data to assess convergence.</p> <p>Note</p> <p>Note that FEPA uses the WHAM package from Grossfield lab estimate the free energy from the COLVAR files and this will not work if WHAM is not in your PATH</p>","path":["Tutorials","Setting up REUS"],"tags":[]}]}